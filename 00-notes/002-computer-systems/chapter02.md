## 第 2 章  信息的表示和处理

*2022-12-04*

1. 十进制是 Fibonacci 从阿拉伯带入欧洲，对，就是那个 Fibonacci。
2. 由于精度有限，浮点数没有结合律，即 (a+b)+c != a+(b+c)，也没有分配率。
3. 整数是精确的，但表示范围相对较小，浮点数是近似的，但表示的范围相对较大。
4. 程序是 32 位 64 位，区别在于程序是如何被编译的，而不是其运行的机器类型。
5. 为了避免同一种类型在不同机器上默认大小不同带来的问题，C99 引入了 int32_t 和 int64_t 类型，明确表示是 4 字节和 8 字节长度。
6. 小端法是低地址存低位，大端法反过来。
7. 不同机器可能使用大小端不同，所以跨网络时，发送端一般将数据转换为网络协议标准格式，接收端再根据标准格式转换为自己的端类型。
8. 强制类型转换不会改变数据本身，只是告诉编译器使用新的数据类型来看待数据。
9. 使用 ASCII 码作为字符码的任何系统上，编码字符串都将得到相同的结果，于字节序和大小无关，所以文本数据比二进制数据具有更强的平台独立性。
10. 不同的机器使用不同且不兼容的指令和编码方式，所以二进制（程序）是不兼容的，现实中很少二进制代码很少能在不同机器之间移植。从机器角度来看，程序仅仅是字节序列，机器没有关于原始程序的任何信息，除了可能有一些帮助调试的辅助表。
11. 布尔代数的命名是因为乔治·布尔在这方面的工作。
12. 布尔运算分配率。
    ```c
    a & (b | c) == (a & b) | (a & c)
    a | (b & c) == (a | b) & ( a | c)
    ```
13. <code>a ^ b ^ a = b</code>
14. Java 只支持有符号数，使用补码编码方式。
15. w 位补码转十进制数技巧，结果 = -{[2 ^ (w - 1)] - [低 (w - 1) 位对应原码值]}。例如 10000101 对应十进制结果位 -(2^7 - 5) = -123。
16. C 语言标准没有要求用补码表示有符号数，但几乎所有的机器都是这么做的。
17. 补码（Two's complement）和反码（Ones' complement）中撇号位置是不同的。术语补码来源于对于非负数 *x* 我们使用 *2^w - x* 来表示计算 *-x* 的 *w* 位表示，这里只有一个 2。术语反码来源于我们用 *[111...1] - x* 来计算 *-x* 的反码形式，这里多个 1。
18. 有符号和无符号运算，会隐式将有符号数转换为无符号数，这种对小于 0 的有符号数隐式转换会变成很大的正数，这经常会带来隐藏的 bug。
19. 两个非负整数 x、y 相加，当且仅当和小于等于 0 时，说明发生了正溢出。两个非正整数 x、y 相加，当且仅当和大于等于 0 时，说明发生了负溢出。
20. 由于整数乘法比移位代价大得多，许多 C 语言编译器试图以移位、加法和减法的组合来消除很多以整数乘以常数的情况。
21. 舍入方法，通常采用向偶数舍入，而不是单纯向上或向下舍入的原因，很快能想到的一个原因是避免对一批数求平均值带来统计偏差。
22. 将大的浮点数转换为整数是一种常见的容易引入 bug 的做法，可能由于溢出导致程序出错。